import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';
import { google } from 'googleapis';
import { getEmployeeDetails } from '@/lib/bigquery';

export const POST = auth(async (req) => {
  try {
    const session = req.auth;
    if (!session?.user?.email || !session.accessToken) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized or missing access token' },
        { status: 401 }
      );
    }

    const body = await req.json();
    const {
      recipients,
      subject,
      message,
      reportItem,
      ccRecipients = [],
      bccRecipients = []
    } = body;

    if (!recipients || recipients.length === 0) {
      return NextResponse.json(
        { success: false, error: 'Recipients required' },
        { status: 400 }
      );
    }

    if (!reportItem?.generationParams) {
      return NextResponse.json(
        { success: false, error: 'Report generation parameters missing' },
        { status: 400 }
      );
    }

    // Initialize Gmail API with user's access token
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET
    );
    
    oauth2Client.setCredentials({
      access_token: session.accessToken,
    });

    const gmail = google.gmail({ version: 'v1', auth: oauth2Client });

    // Validate report item exists
    if (!reportItem) {
      console.error('Send email error: No report item provided');
      return NextResponse.json(
        { error: 'No report item provided' },
        { status: 400 }
      );
    }

    // Get report data with fallback
    const generationParams = reportItem.generationParams || {};
    
    // Determine the format - handle both old and new format
    let reportFormats;
    if (generationParams.reportFormat) {
      // New format - single format string
      reportFormats = {
        pdf: generationParams.reportFormat === 'export-pdf',
        xlsx: generationParams.reportFormat === 'export-xlsx',
        zip: generationParams.reportFormat === 'export-zip'
      };
    } else if (generationParams.formats && generationParams.formats.length > 0) {
      // Handle multiple formats from formats array
      reportFormats = {
        pdf: generationParams.formats.includes('export-pdf'),
        xlsx: generationParams.formats.includes('export-xlsx'),
        zip: generationParams.formats.includes('export-zip')
      };
    } else {
      // Fallback - determine from file type
      const fileType = reportItem.fileType?.toLowerCase() || '';
      reportFormats = {
        pdf: fileType === 'pdf',
        xlsx: fileType === 'excel',
        zip: fileType === 'zip'
      };
    }

    // Extract employee codes with fallback
    const selectedEmployees = generationParams.selectedEmployees || [];
    console.log('Send email - selectedEmployees:', selectedEmployees.length);
    
    const employeeCodes = selectedEmployees.map((emp: any) => 
      typeof emp === 'string' ? emp : (emp?.employee_code || '')
    ).filter(code => code !== '');
    
    // Fetch employee details from BigQuery
    const selectedCategories = generationParams.selectedCategories || {};
    const selectedFields = Object.keys(selectedCategories).filter(
      cat => selectedCategories[cat] && selectedCategories[cat].length > 0
    );
    
    // Only fetch employee data if we have employee codes
    let employeeData = { employeeDetails: [], documents: {} };
    if (employeeCodes.length > 0) {
      employeeData = await getEmployeeDetails(employeeCodes, selectedFields);
    }
    
    // Prepare report data with fallbacks for missing fields
    const reportData = {
      customerName: generationParams.customerName || reportItem.name?.split('_')[0] || 'Unknown',
      reportDate: generationParams.reportDate || new Date().toISOString(),
      employees: employeeData.employeeDetails || [],
      selectedCategories: selectedCategories,
      documents: employeeData.documents || {},
      formats: reportFormats
    };

    // Import report generator dynamically
    const { generateReportBuffer } = await import('@/lib/report-generator');
    
    // Generate the report as a buffer
    const { buffer, mimeType, filename } = await generateReportBuffer(reportData, reportFormats);
    
    // Report generated successfully

    // Create email with attachment
    const emailSubject = subject || `PMO Report - ${reportItem.name}`;
    const emailBody = message || `Please find attached the PMO report: ${reportItem.name}
    
Customer: ${generationParams.customerName}
Report Date: ${generationParams.reportDate}
Generated by: ${session.user.email}

This is an automated email from the Al Laith PMO System.`;

    // Create the email message
    const messageParts = [
      `To: ${recipients.join(', ')}`,
      ...(ccRecipients.length > 0 ? [`Cc: ${ccRecipients.join(', ')}`] : []),
      ...(bccRecipients.length > 0 ? [`Bcc: ${bccRecipients.join(', ')}`] : []),
      'Subject: ' + emailSubject,
      'MIME-Version: 1.0',
      'Content-Type: multipart/mixed; boundary="boundary"',
      '',
      '--boundary',
      'Content-Type: text/plain; charset="UTF-8"',
      'Content-Transfer-Encoding: 7bit',
      '',
      emailBody,
      '',
      '--boundary',
      `Content-Type: ${mimeType}; name="${filename}"`,
      'Content-Transfer-Encoding: base64',
      `Content-Disposition: attachment; filename="${filename}"`,
      '',
      buffer.toString('base64'),
      '--boundary--'
    ].join('\r\n');

    // Log the message structure for debugging
    // Email MIME structure prepared

    // Encode the message
    const encodedMessage = Buffer.from(messageParts).toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');

    // Send the email
    const response = await gmail.users.messages.send({
      userId: 'me',
      requestBody: {
        raw: encodedMessage,
      },
    });

    // Email sent successfully

    return NextResponse.json({
      success: true,
      messageId: response.data.id,
      message: 'Email sent successfully'
    });

  } catch (error: any) {
    console.error('Error sending email:', error);
    
    // Handle specific Gmail API errors
    if (error.code === 403) {
      return NextResponse.json(
        {
          success: false,
          error: 'Gmail access denied. Please re-authenticate with Gmail permissions.',
          requiresReauth: true
        },
        { status: 403 }
      );
    }
    
    return NextResponse.json(
      {
        success: false,
        error: error.message || 'Failed to send email'
      },
      { status: 500 }
    );
  }
});

